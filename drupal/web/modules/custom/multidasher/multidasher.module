<?php

/**
 * @file
 * Contains multidasher.module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\multidasher\Controller\BlockchainController;
use Drupal\multidasher\Controller\ManageRequestsController;
use Drupal\node\Entity\Node;



/**
 * Implements hook_help().
 */
function multidasher_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the multidasher module.
    case 'help.page.multidasher':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Multichain integration for Drupal') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_form_alter().
 */
function multidasher_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Adding custom validation for the welcome page type field.
  if ($form_id == 'node_blockchain_asset_form') {
    $blockchain = \Drupal::request()->query->get('field_asset_blockchain_ref');
    if ($blockchain) {
      // Do some stuff.
      $form['field_asset_blockchain_ref']['widget']['#default_value'][0] = $blockchain;
    }
  }
}

/**
 *
 */
function multidasher_node_update(EntityInterface $entity) {

  if ($entity->bundle() == 'blockchain_wallet') {
    $node = Node::load($entity->id());
    $request = new ManageRequestsController();

    foreach ($node->field_wallet_blockchain_ref as $item) {
      if ($item->entity) {
        $blockchain = $item->entity->label();
      }
    }

    $address = $node->field_wallet_address->getString();

    $permissions_master_string = "activate,admin,connect,create,issue,mine,receive,send";
    $permissions_master = explode(',', $permissions_master_string);
    $permissions = $node->field_wallet_permissions->referencedEntities();
    $permissions_list = [];

    foreach ($permissions as $key => $value) {
      $permissions_list[$key] = $value->getName();
    }

    // Grant permissions to wallet.
    $grant = implode(',', $permissions_list);
    $exec = 'grant';
    $parameters[0] = $address;
    $parameters[1] = $grant;
    $command = $request->executeRequest($blockchain, 'grant', $parameters);

    // Revoke permissions from wallet.
    $revoke_array = array_diff($permissions_list, $permissions_master);
    $revoke = implode(',', $revoke_array);
    $exec = 'revoke';
    $parameters[0] = $address;
    $parameters[1] = $revoke;
    if($revoke){
      $command = $request->executeRequest($blockchain, 'revoke', $parameters);
    }
  }
}

/**
 *
 */
function multidasher_node_insert(EntityInterface $entity) {

  if ($entity->bundle() == 'blockchain_asset') {
    $node = Node::load($entity->id());
    $request = new ManageRequestsController();
    $asset_name = $node->field_asset_name->getString();
    $asset_quantity = $node->field_asset_quantity->getString();
    $asset_open = $node->field_asset_open->getString();
    $description = $node->field_asset_description->getString();
    $command = 'issue';
    $address_node = Node::load($node->field_asset_issue_address->getString());
    $address = $address_node->field_wallet_address->getString();
    $blockchain_node = Node::load($node->field_asset_blockchain_ref->getString());
    $blockchain = $blockchain_node->field_blockchain_id->getString();
    $parameters[0] = $address;
    $parameters[1] = json_encode([
      'name' => $asset_name,
      'open' => $asset_open,
    ]);
    $parameters[2] = +$asset_quantity;
    $response = $request->executeRequest($blockchain, $command, $parameters);
    if($response['error']['message']){
      drupal_set_message($response['error']['message'], 'error');
      throw new \Exception($response['error']['message']);
    }else{
      drupal_set_message('Congratulations, you have issued ' . $asset_quantity . ' ' . $asset_name . ' to ' . $address);
    }
  }

  if ($entity->bundle() == 'blockchain_wallet') {
    $node = Node::load($entity->id());

    foreach ($node->field_wallet_blockchain_ref as $item) {
      if ($item->entity) {
        $blockchain = $item->entity->label();
      }
    }

    $exec = 'get_new_address';
    $multichain = new BlockchainController();
    $command = $multichain->constructSystemCommand($exec, $blockchain);
    drupal_set_message($command);

    $result = shell_exec($command." &");
    drupal_set_message($result);
    if(!$result){
      drupal_set_message('something went wrong','error');
      throw new \Exception('something went wrong');
      return;
    }

    $node->field_wallet_ismine->setValue(TRUE);
    $address =  preg_replace('/\s+/', '', $result);
    $node->field_wallet_address->setValue($address);
    $node->title->setValue($address);

    $permissions_master_string = "activate,admin,connect,create,issue,mine,receive,send";
    $permissions_master = explode(',', $permissions_master_string);
    $permissions = $node->field_wallet_permissions->referencedEntities();
    $permissions_list = [];

    foreach ($permissions as $key => $value) {
      $permissions_list[$key] = $value->getName();
    }

    // Grant permissions to wallet.
    $grant = implode(',', $permissions_list);
    $exec = 'grant';
    $parameters[0] = $address;
    $parameters[1] = $grant;
    $request = new ManageRequestsController();
    $request->executeRequest($blockchain, 'grant', $parameters);
    // drupal_set_message($result);
    // drupal_set_message($result);

    $node->save();
  }
}
